<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>AR – drzewa z OpenStreetMap</title>

  <!-- A-Frame + AR.js (location based) -->
  <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
  <script src="https://unpkg.com/aframe-look-at-component@0.8.0/dist/aframe-look-at-component.min.js"></script>

  <style>
    body, html { margin: 0; padding: 0; overflow: hidden; background: #000; }
    #hud {
      position: fixed;
      top: 10px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.6); color: #fff; padding: 8px 12px;
      border-radius: 8px; font-family: system-ui, Arial, sans-serif; z-index: 10;
      text-align: center; font-size: 14px; line-height: 1.3;
    }
    #hud small { display:block; opacity: .7; }
    #error { color: #ff6b6b; }
  </style>
</head>
<body>
  <div id="hud">
    <div id="status">Oczekiwanie na GPS…</div>
    <small>Overpass/OSM → natural=tree</small>
    <div id="error"></div>
  </div>

  <a-scene
    vr-mode-ui="enabled: true"
    embedded
    renderer="logarithmicDepthBuffer: true; antialias: true"
    arjs="sourceType: webcam; videoTexture: true; debugUIEnabled: false;"
  >
    <!-- Kamera z GPS -->
    <a-camera gps-camera rotation-reader></a-camera>
  </a-scene>

  <script>
    const RADIUS_METERS = 250;   // promień zapytania wokół użytkownika
    const MAX_TREES = 150;       // limit 3D obiektów (żeby nie zabić wydajności)
    const TREE_MIN_H = 2.0;      // minimalna wysokość cylindra (m)
    const TREE_MAX_H = 8.0;      // maksymalna wysokość cylindra (m)

    const statusEl = document.getElementById('status');
    const errorEl  = document.getElementById('error');

    function fetchTrees(lat, lon) {
      statusEl.textContent = 'Pobieram drzewa z OSM…';

      const url = `https://overpass-api.de/api/interpreter?data=[out:json];node(around:${RADIUS_METERS},${lat},${lon})[natural=tree];out;`;

      return fetch(url)
        .then(r => r.json())
        .then(json => {
          statusEl.textContent = `Znaleziono ${json.elements.length} drzew. Renderuję…`;
          return json.elements.slice(0, MAX_TREES);
        });
    }

    function rand(min, max) {
      return min + Math.random() * (max - min);
    }

    function addTreeToScene(tree) {
      const scene = document.querySelector('a-scene');
      const cyl = document.createElement('a-cylinder');
      const h = rand(TREE_MIN_H, TREE_MAX_H).toFixed(2);

      cyl.setAttribute('gps-entity-place', `latitude: ${tree.lat}; longitude: ${tree.lon}`);
      cyl.setAttribute('height', h);
      cyl.setAttribute('radius', 0.15);
      cyl.setAttribute('color', '#228B22');
      cyl.setAttribute('opacity', 0.9);
      cyl.setAttribute('look-at', '[gps-camera]');

      scene.appendChild(cyl);
    }

    function onPosition(pos) {
      const lat = pos.coords.latitude;
      const lon = pos.coords.longitude;
      const acc = pos.coords.accuracy;

      statusEl.textContent = `Twoja pozycja: ${lat.toFixed(6)}, ${lon.toFixed(6)} (±${acc.toFixed(0)} m)`;

      // Pobierz drzewa tylko raz (na starcie) – można łatwo przerobić na aktualizację co X metrów
      if (!window._treesLoaded) {
        window._treesLoaded = true;
        fetchTrees(lat, lon)
          .then(trees => {
            if (!trees || !trees.length) {
              statusEl.textContent = 'Brak drzew w pobliżu (OSM). Zmień promień lub lokalizację.';
              return;
            }
            trees.forEach(addTreeToScene);
            statusEl.textContent += ` | Wyrenderowano ${Math.min(trees.length, MAX_TREES)} drzew`;
          })
          .catch(err => {
            errorEl.textContent = 'Błąd pobierania z Overpass API: ' + err.message;
          });
      }
    }

    function onError(err) {
      errorEl.textContent = 'GPS error: ' + err.message;
    }

    if ('geolocation' in navigator) {
      navigator.geolocation.watchPosition(onPosition, onError, {
        enableHighAccuracy: true,
        maximumAge: 5000,
        timeout: 20000
      });
    } else {
      errorEl.textContent = 'Brak wsparcia dla Geolocation API.';
    }
  </script>
</body>
</html>
